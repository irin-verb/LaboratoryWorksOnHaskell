module L4 where

-- cd <путь к папке с файлом .hs>
-- ghci
-- :l <имя файла>
-- :r

sumSq a b = a^2 + b^2
funConst = 40
-- let funConst = 40
-- :type sumSq

-- infix Если ассоциативность не определена

infixl 6 |-|
(|-|) a b = if a > b then a - b else b - a

-- let max5 x = max 5 x
-- let max5' = max 5

-- let add a b с = a + b + c
-- let add5 = add 5
-- add5 6 7

-- import Prelude hiding (($))
-- f $ x = f x

-- Перепишите выражение logBase 4 (min 20 (9+7)) без скобок
-- logBase 4 $ min 20 $ 9+7

-- Пример использования flip
-- flip принимает функцию с двумя параметрами, которые переставляются.
-- zip [1, 2, 3] "ABC"
-- [(1,'A'),(2,'B'),(3,'C')]
-- flip zip [1, 2, 3] "ABC"
-- [('A',1),('B',2),('C',3)]

-- Явно задать конкретный тип
-- let x=3::Int
-- let y=3::Double

-- Определить функцию twice, которая дважды применяет функцию f к переданному аргументу x.
twice :: (a -> a) -> a -> a
twice f x = f (f x)

-- «Подружить» целые числа и дробные, используется функция fromIntegral, которая превращает целое число в класс Num (более общее число)
-- fromIntegral(25 `mod` 8) + 5.5 => 6.5

-- Функция compare принимает два значения одного и того же типа, являющегося экземпляром класса Ord, и возвращает значение типа Ordering, 
-- к-ый может принимать значения GT, LT или EQ, означая, соответственно, «больше чем», «меньше чем» и «равно».
-- "хороший" `compare` "плохой" => GT

-- Пояснение. Функция show берёт значение и представляет его в виде строки.
-- "answer = " ++ show(123/8) => "answer = 15.375"

-- Функция read
-- read "4" :: Int => 4
-- read "(3, 'a')" :: (Int, Char) => (3,'a')



-- Собственный оператор - сравнение длины двух строк - длиннее ли правая
infixr 9 ###
a ### b = (length b > length a)

-- Определить, является ли треугольник прямоугольным
task_1 :: Double -> Double -> Double -> Bool
task_1 a b c = (a^2 == b^2 + c^2) || (b^2 == a^2 + c^2) || (c^2 == a^2 + b^2)

-- Определить "знак числа"
task_2 :: Double -> Double
task_2 x = if (x==0) then 0 else if (x<0) then -1 else 1



-- Кортеж 
-- (5, False, 'r') 
-- fst (1, 'y') => 1
-- snd (1, 'y') => 'y'

-- Функция, которая находит расстояние между двумя точками на плоскости
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt ((fst p1 - fst p2 )^ 2 + (snd p1 - snd p2) ^ 2)

-- Список
-- [1, 2, 3]
-- [False, True]

-- оператор !!.
-- [2, 33, 28, 15] !! 1
--33
-- let ls = [[6, 7, 9, 4, 0], [89], [100, 233, 850]]
-- ls !! 2 !! 1
-- 233

-- : – добавление элемента в голову списка;
-- ++ – конкатенация списков.
-- :info (:)
